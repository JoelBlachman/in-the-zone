#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    PowerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in4,    flipPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    modePot,        sensorPotentiometer)
#pragma config(Sensor, in7,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    mobilePot,      sensorPotentiometer)
#pragma config(Motor,  port2,           driveLF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveLB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           liftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           driveRF,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           driveRB,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           flip,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          mobile,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Sensors")
#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("taskStatus")
//#pragma DebuggerWindows("debugStream")
//#pragma DebuggerWindows("VexLCD")

/*---------------------------------------------------------------------------*/
/*        Description: Competition template for VEX EDR                      */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Under Robot Menu, Set Cortex Communication Mode to "Competition"
#pragma competitionControl(Competition)

// Included Libraries:
#include "Vex_Competition_Includes.c"		// Main competition background code
#include "gyroLib.c"										// JPearman's Gyro Library
#include "C_Func.c"								  		// Function Library
#include "C_Auton.c"										// Autonomous Routine Library

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	AutonSelector();
	GyroInit();														// Gyro calibration
	wait1Msec(1700);


}

/*---------------------------------------------------------------------------*/
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*---------------------------------------------------------------------------*/

task autonomous()
{

	//getAutonRoutine();
	//AutonPrgm = AutonSelection

	switch(AutonSelection)
	{
	case 1:		startTask (ProgrammingSkills);		break;
	case 2:		startTask (StationaryR);		break;
	case 3:		startTask (StationaryL);		break;
	case 4:		startTask (Mogo5Right);			break;
	case 5:		startTask (Mogo5Left);			break;
	case 6:		startTask (DoNothing);			break;
	default:	// nothing
	}


}

/*---------------------------------------------------------------------------*/
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*---------------------------------------------------------------------------*/

// Joystick Mappings
// Ch1   - Rotate robot Left/Right
// Ch2   - N/A
// Ch3   - Move robot Forward/Backward
// Ch4   - N/A
// Btn5U - (Manual Mode) Lift Up or (Auto Mode) Stack Cone
// Btn5D - (Manual Mode) Lift Down
// Btn6U - Claw Toggle
// Btn6D - Flipper Toggle
// Btn7U - N/A
// Btn7D - Switch between Manual/Auto stacking
// Btn7L - Reset Auto Lift Cone State to 1st cone
// Btn7R - Restart Tasks (kill/reset button)
// Btn8U - N/A
// Btn8D - Mobile Goal Mid Toggle
// Btn8L - N/A
// Btn8R - Mobile Goal Toggle

task usercontrol()
{
	int clawBtnPressed = 0;						 //Determines if claw button is pressed
	int mobileBtnPressed = 0;					 //Determines if mobile button is pressed
	int mobileBtnMidPressed = 0;			 //Determines if mobile mid button is pressed
	int flipBtnPressed = 0;						 //Determines if flip button is pressed

	clawTarget = SensorValue[clawPot]; // Enable if we want to manually adjust claw position for the start
	mobileTarget = SensorValue[mobilePot]; // Sets value of mobile pot to mobileTarget
	flipTarget = SensorValue[flipPot];	//Prevent flipper from closing on something

	const unsigned short Linearize[128] = 		// Remapping array to linearize motor control values
	{																					// Compensates for non-linearity of control value vs speed curve
		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,	// Making this array local clears up the debugger windows
		0, 21, 21, 21, 22, 22, 22, 23, 24, 24,  // Array is const unsigned short to prevent ROBOTC download errors
		25, 25, 25, 25, 26, 27, 27, 28, 28, 28,
		28, 29, 30, 30, 30, 31, 31, 32, 32, 32,
		33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
		37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
		41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
		46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
		52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
		61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
		71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
		80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
		88, 89, 89, 90, 90,127,127,127
	};

	startTask(clawPID);			// Start claw PID Task
	startTask(flipPID);			// Start flip PID Task
	startTask(mobilePID);		// Start mobile PID Task
	startTask(LCDVoltage);	// Start LCD Voltage display task
	startTask(LCDBatteryFlash); // Start LCD battery monitoring task

	clawTarget = SensorValue(clawPot);  //All subsystems hold current values
	flipTarget = SensorValue(flipPot);
	mobileTarget = SensorValue(mobilePot);

	while(true)
	{

		//CHASSIS---------------------------------------------------------------------------------------------------------------
		// Drive Control
		// The drive uses 2 joysticks and deadzones to ensure precise movement
		// Control layout is like an R/C car with dedicated joysticks for moving forward/backward and rotating left/right
		// The motor power is based on the sum of inputs from the controller and tasks
		// The sum of the inputs is then mapped to an array to linearize the RPM in relation to motor power
		// The drive has a multiplier to slow down in-place turns to make the robot more controllable

		if(abs(vexRT[Ch1]) > DEADZONE)	// Create "deadzone" of ±10 for Y1 (Ch3)
			X2 = vexRT[Ch1];
		else
			X2 = 0; // Otherwise prevent robot from movign forward
		if(abs(vexRT[Ch3]) > DEADZONE)	// Create "deadzone" of ±10 for X2 (Ch1)
			Y1 = (vexRT[Ch3] * Y1_Mult);	// Multiply by constant to slow down turning and increase control
		else
			Y1 = 0; // Otherwise prevent robot from rotating

		rawRF = Y1 - X2; // Calculate raw sum of input values for each motor
		rawRB = Y1 - X2;
		rawLB = X2 + Y1;
		rawLF = X2 + Y1;
		trimDrive();
		// Scale each sum to compensate for motor variation and linearize
		motor[driveRF] = driveMultRF * Linearize[fabs(rawRF)] * sgn(rawRF);
		motor[driveRB] = driveMultRB * Linearize[fabs(rawRB)] * sgn(rawRB);
		motor[driveLF] = driveMultLF * Linearize[fabs(rawLF)] * sgn(rawLF);
		motor[driveLB] = driveMultLB * Linearize[fabs(rawLB)] * sgn(rawLB);
		wait1Msec(25); // Run the loop once every 25ms to prevent hogging the Cortex and causing instability


		//CLAW------------------------------------------------------------------------------------------------------------------
		// Claw Control
		// The claw uses a Proportional Control algorithm to set the motor power levels based on the angle of the claw potentiometer
		// The claw is operated by a toggle which sets the claw to different preset positions
		// The claw can be opened and closed by either the controller, or automatically when the lift is raised.
		if((vexRT[Btn6U])) // Claw toggle reduces driver fatigue by setting the Open and Close functions to the same button
		{
			// Toggle between Open and Closed states
			if(!clawBtnPressed && (clawState == 0 || clawState == 1)) // Only change the toggle state if claw is in the Open or Closed position
			{
				clawState = 1 - clawState;	// Change the toggle state
				clawBtnPressed = 1;					// Note the button is pressed
			}

			// Returns to the toggle states if claw is in a different state
			else if(!clawBtnPressed && (clawState != 0 || clawState != 1)) // If claw is not in open or closed position close the claw
			{
				clawState = 0;				// Reset the claw state
				clawBtnPressed = 1;		// Note the button is pressed
			}
		}

		else
			clawBtnPressed = 0;		// Claw toggle button is not pressed, clawState is able to be toggled

		switch(clawState) // Assign claw state to claw
		{
		case 0: clawTarget = CLAW_CLOSE; 	clawHold = true; 	break;			// Sets claw to Close Position
		case 1: clawTarget = CLAW_OPEN; clawHold = false;	break;	// Sets claw to Open Position
		default: // nothing
		}

		//LIFT------------------------------------------------------------------------------------------------------------------

		if(vexRT[Btn5U] == 1 && vexRT[Btn5D] == 0) {
			motor[liftR] = motor[liftL] = 127;
			} else if(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 0) {
			motor[liftR] = motor[liftL] = -127;
			} else if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0) {
			motor[liftR] = motor[liftL] = 0;
		}

		//FLIP------------------------------------------------------------------------------------------------------------------

		if((vexRT[Btn6D])) {						//Mobile goal general toggle
			if(!flipBtnPressed && (flipState == 0 || flipState == 1)) {			//if button is pressed, toggle between flip states
				flipState = 1 - flipState;
				flipBtnPressed = 1;										// Note the button is pressed
				} else if(!flipBtnPressed && (flipState != 0 || flipState != 1)) {		//if button is pressed and flipper is neither front or back, send to front
				flipState = 1;
				flipBtnPressed  = 1;									// Note the button is pressed
			}
		}

		else
			flipBtnPressed = 0;											// Note the button is not pressed


		if(flipState == 0) {
			flipTarget = FLIP_MIN;
			} else if(flipState == 1) {
			flipTarget = FLIP_MAX;
		}

		//Mobile------------------------------------------------------------------------------------------------------------------

		if((vexRT[Btn8R])) {
			if(!mobileBtnPressed && (mobileState == 0 || mobileState == 1)) {			//if button is pressed, toggle between mobile extended and mobile in
				mobileState = 1 - mobileState;
				mobileBtnPressed = 1;										// Note the button is pressed
				} else if(!mobileBtnPressed && (mobileState != 0 || mobileState != 1)) {		//if button is pressed and mobile is neither in nor out, bring mobile in
				mobileState = 0;
				mobileBtnPressed  = 1;									// Note the button is pressed
			}
		}

		else
			mobileBtnPressed = 0;											// Note the button is not pressed

		if(mobileState == 0)
			mobileTarget = MOBILE_MIN;
		else if(mobileState == 1)
			mobileTarget = MOBILE_MAX;
		else if(mobileState == 2)
			mobileTarget = MOBILE_MID;

		if((vexRT[Btn8D])) {								//Mobile Goal Mid Toggle
			if(!mobileBtnMidPressed && (mobileMidState == 0 || mobileMidState == 1)) {			//if button is pressed, toggle between mobile extended and mobile in
				mobileMidState = 1 - mobileMidState;
				if(mobileMidState == 0 && mobileState != 0)
					mobileState = 0;
				else if(mobileMidState == 0 && mobileState == 0)
					mobileState = 2;
				else if(mobileMidState == 1)
					mobileState = 2;
				mobileBtnMidPressed = 1;										// Note the button is pressed
				} else if(!mobileBtnMidPressed && (mobileMidState != 0 || mobileMidState != 1)) {		//if button is pressed and mobile is neither in nor out, bring mobile in
				mobileMidState = 1;
				if(mobileMidState == 0 && mobileState != 0)
					mobileState = 0;
				else if(mobileMidState == 0 && mobileState == 0)
					mobileState = 2;
				else if(mobileMidState == 1)
					mobileState = 2;
				mobileBtnMidPressed  = 1;									// Note the button is pressed
			}
		}

		else
			mobileBtnMidPressed = 0;											// Note the button is not pressed


		//Restart Btn---------------------------------------------------------------------------------------------------------------

		if(vexRT[Btn7R]) {
			stopTask(clawPID);			// Stop claw PID Task
			stopTask(flipPID);			// Stop flip PID Task
			stopTask(mobilePID);		// Stop mobile PID Task

			motor[claw] = motor[liftR] = motor[liftL] = motor[flip] = motor[mobile] = motor[driveLB] = motor[driveLF] = motor[driveRB] = motor[driveRF] = 0;
			wait1Msec(500);

			startTask(clawPID);			// Start claw PID Task
			startTask(flipPID);			// Start flip PID Task
			startTask(mobilePID);		// Start mobile PID Task
		}

	}
}
